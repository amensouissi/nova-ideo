# -*- coding: utf-8 -*-
#************************************************************
#*       
#* Code automatically generated by OMEGSI
#*
#************************************************************
import re
from zope.interface import Interface, implementer
from dace.util import utility
from diff_match_patch import diff_match_patch 
from bs4 import BeautifulSoup
from bs4.element import NavigableString

from novaideo.ips.htmldiff import htmldiff

 

class ITextAnalyzer(Interface):
    """TODO IText_analyzer
    """

    def hasConflict(originetexte, textes):
        pass

    def merge(originetexte, textes):
        pass

    def render_html_diff(text1, text2):
        pass

    def wrap_diff(diff, diffid):
        pass


@utility(name='text_analyzer')
@implementer(ITextAnalyzer)
class TextAnalyzer(object):
    """TODO text_analyzer
    """

    def hasConflict(self, originetexte, textes):
        d = diff_match_patch()
        d.Match_Threshold = 0.1
        result = originetexte
        haseconflict = False
        for alternatif in textes:
            result, results = d.patch_apply(d.patch_make(originetexte, alternatif), result)
            if False in results:
                haseconflict = True
                break

        return haseconflict

    def merge(self, originetexte, textes):
        d = diff_match_patch()
        d.Match_Threshold = 0.1
        texteresult = originetexte
        conflict = False
        for alternatif in textes:
            texteresult, results = d.patch_apply(d.patch_make(originetexte, alternatif), texteresult)
            if False in results:
                conflict = True
                break

        return texteresult

    def render_html_diff(self, text1, text2, diffid="diffid"):
        text1 = text1.replace('&nbsp;', '')
        text2 = text2.replace('&nbsp;', '')
        result = htmldiff.render_html_diff(text1, text2)
        soup = self.wrap_diff(result.replace('\xa0',' '), diffid)
        return soup, u''.join([str(t) for t in soup.body.contents])
  
    def _del_next_s(self, soup, tag):
        next_sibling = tag.next_sibling
        if isinstance(next_sibling, NavigableString):
            if next_sibling[0] == ' ':
                new_string = soup.new_string(tag.next_sibling[1:next_sibling.__len__()])
                tag.next_sibling.replace_with(new_string)

    def wrap_diff(self, diff, diffid):
        soup = BeautifulSoup(diff)
        ins_tags = soup.find_all('ins')
        del_tags = soup.find_all('del')
        del_included = []
        for ins_tag in ins_tags:
            new_tag = soup.new_tag("span", id=diffid)
            previous_del_tag = ins_tag.find_previous_sibling('del')
            correct_exist = False
            inst_string = ins_tag.string
            if previous_del_tag is not None:
                previous_del_tag_string = previous_del_tag.string
                tofind = str(previous_del_tag) +' *'+ str(ins_tag)
                modif_exist = (len(re.findall(tofind, diff)) >0)
                if previous_del_tag_string != inst_string and modif_exist:
                    self._del_next_s(soup, previous_del_tag)
                    previous_del_tag.wrap(new_tag)
                    new_tag.append(ins_tag)
                    del_included.append(previous_del_tag)
                    continue
                elif modif_exist:
                    del_included.append(previous_del_tag)
                    self._del_next_s(soup, previous_del_tag)
                    ins_tag.unwrap()
                    previous_del_tag.extract()

            if ins_tag.parent is not None:
                ins_tag.wrap(new_tag)

        for del_tag in del_tags:
            if not(del_tag in del_included):
                if del_tag.string is not None:
                    new_tag = soup.new_tag("span", id=diffid)
                    del_tag.wrap(new_tag)
                else:
                    self._del_next_s(soup, del_tag)
                    del_tag.extract()        

        return soup

    def unwrap_diff(self, tags_data, soup, unwrap_ins=True):
        for tag_data in tags_data:
            tag = tag_data['tag']
            todel = tag_data['todel']
            toins = tag_data['toins']
            bloctodel = tag_data['blocstodel']
            del_tags = tag.find_all(todel)
            del_tags_empty = len(del_tags) == 0
            ins_tags = tag.find_all(toins)
            ins_tags_empty = len(ins_tags) == 0
            if del_tags:
                for del_tag in del_tags:
                    del_tag.extract()

            if ins_tags and unwrap_ins:
                for ins_tag in ins_tags:
                    ins_tag.unwrap()

            if bloctodel is not None:
                blocs = tag.find_all(bloctodel[0], bloctodel[1])
                for bloc in blocs:
                    bloc.extract()

            if tag.contents and tag.contents[tag.contents.__len__()-1]=='\n':
                tag.contents.pop()

            if not del_tags_empty and ins_tags_empty:
                #TODO del space
                self._del_next_s(soup, tag)

            tag.unwrap()

    def render_html_diff_del(self, text1, text2):
        soup, diff = self.render_html_diff(text1, text2, "modif")
        modifs_data = []
        modifs = soup.find_all('span', {'id':'modif'})
        for modif in modifs:
            modif_data = {'tag': modif,
                                'todel': "ins",
                                'toins': "del",
                                'blocstodel': None
                                }
            modifs_data.append(modif_data)

        self.unwrap_diff(modifs_data, soup, False)
        diff_div = soup.find_all('div', {'class':'diff'})
        for d in diff_div:
            d.unwrap()

        return u''.join([str(t) for t in soup.body.contents])


    def update_text(self, new_text, old_text, text):
        soup, deleted_text = self.render_html_diff_del(old_text, text, "modif")
        soupdiff, diff = self.render_html_diff(new_text, deleted_text, "modif")
        ins_tags = soupdiff.find_all('ins')
        del_tags = soupdiff.find_all('del')
        valid_del_tags = []
        valid_ins_tags = []
        for del_tag in del_tags:
            del_parents = del_tag.find_parents('del')
            if del_parents:
                continue
 
            valid_del_tags.append(del_tag)

        for ins_tag in ins_tags:
            ins_parents = ins_tag.find_parents('del')
            if ins_parents:
                continue
 
            valid_ins_tags.append(ins_tag)

        for tag in valid_del_tags:
            new_tag = soupdiff.new_tag('span', type='del')
            tag.wrap(new_tag)
            tag.unwrap()

        for tag in valid_ins_tags:
            new_tag = soupdiff.new_tag('span', type='ins')
            tag.wrap(new_tag)
            tag.unwrap()

        diff = u''.join([str(t) for t in soupdiff.body.contents])
        modifs_data = []
        modifs = soupdiff.find_all('span', {'id':'modif'})
        for modif in modifs:
            modif_data = {'tag': modif,
                                'todel': "ins",
                                'toins': "del",
                                'blocstodel': None
                                }
            modifs_data.append(modif_data)

        self.unwrap_diff(modifs_data, soupdiff)
        del_tags = soupdiff.find_all('span', {'type':'del'})
        ins_tags = soupdiff.find_all('span', {'type':'ins'})
        for tag in ins_tags:
            new_tag = soupdiff.new_tag('ins')
            tag.wrap(new_tag)
            tag.unwrap()

        for tag in del_tags:
            new_tag = soupdiff.new_tag('del')
            tag.wrap(new_tag)
            tag.unwrap()

        soupdiff = self.wrap_diff(diff, "modif")
        modifs_data = []
        modifs = soupdiff.find_all('span', {'id':'modif'})
        for modif in modifs:
            modif_data = {'tag': modif,
                                'todel': "del",
                                'toins': "ins",
                                'blocstodel': None
                                }
            modifs_data.append(modif_data)

        self.unwrap_diff(modifs_data, soupdiff)
        new_diff = u''.join([str(t) for t in soupdiff.body.contents])
        return self.merge(new_text, [text, new_diff])
