# -*- coding: utf-8 -*-
#************************************************************
#*       
#* Code automatically generated by OMEGSI
#*
#************************************************************
import re
from zope.interface import Interface, implementer
from dace.util import utility
from diff_match_patch import diff_match_patch 
from bs4 import BeautifulSoup
from bs4.element import NavigableString

from novaideo.ips.htmldiff import htmldiff

 

class ITextAnalyzer(Interface):
    """TODO IText_analyzer
    """

    def hasConflict(originetexte, textes):
        pass

    def merge(originetexte, textes):
        pass

    def render_html_diff(text1, text2):
        pass

    def wrap_diff(diff, diffid):
        pass


@utility(name='text_analyzer')
@implementer(ITextAnalyzer)
class TextAnalyzer(object):
    """TODO text_analyzer
    """

    def hasConflict(self, originetexte, textes):
        d = diff_match_patch()
        d.Match_Threshold = 0.1
        result = originetexte
        haseconflict = False
        for alternatif in textes:
            result, results = d.patch_apply(d.patch_make(originetexte, alternatif), result)
            if False in results:
                haseconflict = True
                break

        return haseconflict

    def merge(self, originetexte, textes):
        d = diff_match_patch()
        d.Match_Threshold = 0.1
        texteresult = originetexte
        conflict = False
        for alternatif in textes:
            texteresult, results = d.patch_apply(d.patch_make(originetexte, alternatif), texteresult)
            if False in results:
                conflict = True
                break

        return texteresult

    def render_html_diff(self, text1, text2):
        text1 = text1.replace('&nbsp;', ' ')
        text2 = text2.replace('&nbsp;', ' ')
        result = htmldiff.render_html_diff(text1, text2)
        #result = result.replace('</del> <ins>','</del><ins>')
        return result.replace('\xa0',' ')

    def wrap_diff(self, diff, diffid):
        soup = BeautifulSoup(diff)
        ins_tags = soup.find_all('ins')
        del_tags = soup.find_all('del')
        del_included = []
        for ins_tag in ins_tags:
            new_tag = soup.new_tag("span", id=diffid)
            previous_del_tag = ins_tag.find_previous_sibling('del')
            correct_exist = False
            inst_string = ins_tag.string
            if previous_del_tag is not None:
                previous_del_tag_string = previous_del_tag.string
                del_included.append(previous_del_tag)
                if previous_del_tag_string != inst_string:
                    tofind = str(previous_del_tag) +' *'+ str(ins_tag)
                    modif_exist = (len(re.findall(tofind, diff)) >0)
                    if modif_exist:
                        previous_del_tag.wrap(new_tag)
                        new_tag.append(ins_tag)
                        continue
                else:
                    ins_tag.unwrap()
                    previous_del_tag.extract()

            if ins_tag.parent is not None:
                ins_tag.wrap(new_tag)

        for del_tag in del_tags:
            if not(del_tag in del_included):
                if del_tag.string is not None:
                    new__tag = soup.new_tag("span", id=diffid)
                    del_tag.wrap(new_tag)
                else:
                    del_tag.extract()        

        return soup

    def unwrap_diff(self, tags_data, soup):
        for tag_data in tags_data:
            tag = tag_data['tag']
            todel = tag_data['todel']
            toins = tag_data['toins']
            bloctodel = tag_data['blocstodel']
            del_tags = tag.find_all(todel)
            del_tags_empty = len(del_tags) == 0
            ins_tags = tag.find_all(toins)
            ins_tags_empty = len(ins_tags) == 0
            if del_tags:
                for del_tag in del_tags:
                    del_tag.extract()

            if ins_tags:
                for ins_tag in ins_tags:
                    ins_tag.unwrap()

            if bloctodel:
                blocs = tag.find_all(bloctodel[0], bloctodel[1])
                for bloc in blocs:
                    bloc.extract()

            if tag.contents[tag.contents.__len__()-1]=='\n':
                tag.contents.pop()

            if del_tags_empty and not ins_tags_empty:
                #TODO del space
                next_sibling = tag.next_sibling
                if isinstance(next_sibling, NavigableString):
                    if next_sibling[0] == ' ':
                        new_string = soup.new_string(tag.next_sibling[1:next_sibling.__len__()])
                        tag.next_sibling.replace_with(new_string)

            tag.unwrap()
